<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cuadr√≠cula</title>
  <style>
    :root {
      --bg: #9f9f9f;
      --cols: 120;
      --rows: 60;
      --margin-cells: 3;
      --cell: 16px;
      --cell-x: 16px;
      --cell-y: 18px;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 12px;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      color: #fff;
    }
    .viewport {
      position: relative;
      width: calc(100vw - 24px);
      aspect-ratio: 16 / 9;
      max-height: calc(100vh - 24px);
      overflow: hidden;
      background: var(--bg);
      border: 1px solid rgba(255,255,255,0.35);
      box-shadow: 0 10px 22px rgba(0,0,0,0.18);
    }
    .map-overlay {
      position: absolute;
      inset: 0;
      background: url("/static/mapa_referencia.png") center/100% 100% no-repeat;
      opacity: 0.65;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1;
    }
    .map-overlay.hidden {
      opacity: 0;
    }
    .grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: transparent;
      background-image:
        linear-gradient(rgba(255,255,255,0.5) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.5) 1px, transparent 1px);
      background-size: var(--cell-x) var(--cell-y);
      z-index: 2;
    }
    .points-layer {
      position: absolute;
      inset: 0;
      z-index: 4;
      pointer-events: none;
      display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      grid-template-rows: repeat(var(--rows), 1fr);
      width: 100%;
      height: 100%;
    }
    .zoom-bubble {
      position: absolute;
      display: inline-block;
      width: auto;
      min-width: 0;
      max-width: none;
      padding: 8px 10px;
      background: #f95e8a;
      color: #0b0c0c;
      border: none;
      box-shadow: 0 10px 24px rgba(0,0,0,0.4);
      font-size: 0.88rem;
      line-height: 1.3;
      transform: translate(-50%, -120%);
      pointer-events: none;
      opacity: 0;
      z-index: 8;
      animation: zoomFlash 0.7s ease-in-out infinite alternate;
    }
    .zoom-bubble.visible {
      opacity: 1;
    }
    .zoom-bubble strong {
      display: block;
      color: #0b0c0c;
      margin-bottom: 4px;
      font-size: 0.95rem;
      white-space: nowrap;
    }
    @keyframes zoomFlash {
      from { background: #f95e8a; }
      to { background: #ff7fa6; }
    }
    .zoom-target {
      transform-origin: center center;
      transition: transform 1.4s cubic-bezier(0.25, 0.1, 0.2, 1);
    }
    .rays-layer {
      position: absolute;
      inset: 0;
      z-index: 3;
      pointer-events: none;
    }
    .marker-pair {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      width: 100%;
      height: 100%;
    }
    .marker {
      position: relative;
      background: #f95e8a;
      color: #111;
      font-size: 11px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      text-shadow: none;
      width: 100%;
      height: 100%;
    }
    .marker.no-comments {
      background: #ffffff;
      color: #111;
      border: 1px solid rgba(0,0,0,0.2);
    }
    .marker.external {
      background: rgba(249, 94, 138, 0.5);
    }
    .marker.is-zoomed {
      animation: zoomPulse 0.6s ease-in-out infinite alternate;
      box-shadow: 0 0 0 4px #ffffff, 0 0 0 16px rgba(255,92,249,0.5);
      z-index: 15;
      background: #000 !important;
      color: #fff !important;
      transform: scale(1.08);
    }
    .marker.is-zoomed::after {
      content: "";
      position: absolute;
      inset: -6px;
      border: 2px solid rgba(255,92,249,0.9);
      box-shadow: 0 0 18px rgba(255,92,249,0.8);
      pointer-events: none;
    }
    @keyframes zoomPulse {
      from { box-shadow: 0 0 0 4px #ffffff, 0 0 0 16px rgba(255,92,249,0.5); }
      to { box-shadow: 0 0 0 10px #ffffff, 0 0 0 26px rgba(255,92,249,0.35); }
    }
    .marker.gender {
      font-size: 0;
      background: #999;
    }
    .marker.study {
      font-size: 0;
      background: #ccc;
    }
    .info {
      position: absolute;
      right: 12px;
      bottom: 12px;
      background: rgba(0,0,0,0.35);
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.85rem;
      letter-spacing: 0.01em;
      backdrop-filter: blur(4px);
      z-index: 5;
      pointer-events: auto;
    }
    .info strong { font-weight: 700; }
    .info kbd {
      display: inline-block;
      padding: 2px 6px;
      margin-left: 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.45);
      background: rgba(0,0,0,0.25);
      font-size: 0.78rem;
    }
    .info .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .info button {
      margin-left: 8px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.45);
      background: rgba(0,0,0,0.3);
      color: #fff;
      cursor: pointer;
      font-size: 0.8rem;
    }
    .ray {
      position: absolute;
      pointer-events: none;
    }
    .timeline {
      position: absolute;
      inset: 0;
      z-index: 5;
      pointer-events: none;
    }
    .timeline__bubble {
      position: absolute;
      display: inline-flex;
      flex-direction: column;
      gap: 6px;
      min-width: 200px;
      max-width: 420px;
      padding: 12px 14px;
      border-radius: 0;
      background: #a6c5bc;
      color: #0b0c0c;
      border: none;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      font-size: 0.9rem;
      opacity: 0;
      transform: translate(-50%, -10px);
      transition: opacity 0.35s ease, transform 0.35s ease;
      left: 50%;
      top: 50%;
      pointer-events: none;
    }
    .timeline__bubble.visible {
      opacity: 1;
      transform: translate(-50%, -18px);
    }
    .stats-timeline {
      position: absolute;
      inset: 0;
      z-index: 5;
      pointer-events: none;
    }
    .stats__bubble {
      position: absolute;
      display: inline-flex;
      flex-direction: column;
      gap: 6px;
      min-width: 200px;
      max-width: 420px;
      padding: 12px 14px;
      background: #a6c5bc;
      color: #0b0c0c;
      border: none;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      font-size: 0.9rem;
      opacity: 0;
      transform: translate(-50%, -18px);
      transition: opacity 0.35s ease, transform 0.35s ease;
      pointer-events: none;
      left: 50%;
      top: 50%;
    }
    .stats__bubble.visible {
      opacity: 1;
      transform: translate(-50%, -18px);
    }
    .character__bubble {
      position: absolute;
      left: 40px;
      bottom: 40px;
      width: 240px;
      display: inline-flex;
      flex-direction: column;
      gap: 8px;
      padding: 14px 14px 12px 14px;
      background: #a6c5bc;
      color: #0b0c0c;
      border: none;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      font-size: 0.9rem;
      opacity: 0;
      transform: translateY(180%);
      transition: transform 0.75s cubic-bezier(0.25, 0.1, 0.2, 1), opacity 0.75s ease;
      pointer-events: none;
      z-index: 6;
    }
    .character__bubble.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .character__img {
      width: 100%;
      aspect-ratio: 3 / 5.5;
      object-fit: contain;
      object-position: center;
      border: none;
      background: transparent;
    }
    .character__label {
      font-weight: 700;
      letter-spacing: 0.01em;
      color: #f8f8f8;
      line-height: 1.2;
    }
    .character__meta {
      font-size: 0.82rem;
      color: #eaeaea;
      opacity: 0.85;
    }
    .character__donut {
      position: relative;
      width: 120px;
      height: 120px;
      align-self: center;
      margin-top: 6px;
    }
    .character__donut-value {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 1.15rem;
      letter-spacing: 0.01em;
      color: #0b0c0c;
    }
    .character__donut-meta {
      text-align: center;
      margin-top: 6px;
      font-size: 0.82rem;
      color: #f8f8f8;
      opacity: 0.9;
    }
    .stats__title {
      font-weight: 700;
      letter-spacing: 0.01em;
      color: #f8f8f8;
    }
    .stats__bar {
      display: flex;
      justify-content: center;
      width: 100%;
    }
    .stats__donut {
      width: 120px;
      height: 120px;
    }
    .stats__rating {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .stats__rating-track {
      position: relative;
      width: 100%;
      height: 16px;
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.25);
      overflow: hidden;
    }
    .stats__rating-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      background: linear-gradient(90deg, #f95e8a, #ffc15c);
    }
    .stats__rating-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #ddd;
    }
    .stats__rating-value {
      font-weight: 700;
      color: #ffd5e4;
    }
    .stats__legend {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 8px;
      font-size: 0.82rem;
    }
    .stats__legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .stats__swatch {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      flex-shrink: 0;
    }
    .stats__meta {
      font-size: 0.85rem;
      color: #ddd;
      opacity: 0.9;
    }
    .timeline__cp {
      font-weight: 700;
      color: #f8f8f8;
      font-size: 0.85rem;
      letter-spacing: 0.02em;
    }
    .timeline__text {
      line-height: 1.3;
      white-space: pre-wrap;
    }
    .word-cloud {
      position: absolute;
      top: 60px;
      left: 40px;
      transform: translateX(0);
      max-width: 30%;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      z-index: 6;
      pointer-events: none;
      align-items: flex-start;
    }
    .word-cloud__item {
      padding: 3px 6px;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(0,0,0,0.65);
      color: #f8f8f8;
      font-weight: 700;
      letter-spacing: 0.02em;
      border-radius: 0;
      transform: translate3d(0,0,0);
      animation: wordFloat var(--wc-duration, 11s) ease-in-out infinite alternate;
    }
    .word-cloud__item.is-active {
      background: #a6c5bc;
      color: #0b0c0c;
      border-color: #a6c5bc;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
    }
    @keyframes wordFloat {
      0% { transform: translate3d(var(--wc-dx, -3px), var(--wc-dy, -2px), 0); }
      25% { transform: translate3d(calc(var(--wc-dx, -3px) * 0.3), calc(var(--wc-dy, -2px) * 0.4), 0); }
      50% { transform: translate3d(calc(var(--wc-dx, -3px) * -0.25), calc(var(--wc-dy, -2px) * 0.2), 0); }
      75% { transform: translate3d(calc(var(--wc-dx, -3px) * 0.15), calc(var(--wc-dy, -2px) * -0.25), 0); }
      100% { transform: translate3d(calc(var(--wc-dx, -3px) * -1), calc(var(--wc-dy, -2px) * -1), 0); }
    }
    .global-rating {
      position: absolute;
      top: calc(var(--cell-y) * 3);
      right: calc(var(--cell-x) * 2.5);
      z-index: 7;
      background: #a6c5bc;
      color: #0b0c0c;
      padding: 12px 14px 14px;
      min-width: 180px;
      box-shadow: 0 12px 24px rgba(0,0,0,0.2);
      border: none;
      text-align: center;
      pointer-events: none;
    }
    .global-rating__title {
      font-weight: 700;
      letter-spacing: 0.01em;
      margin: 0 0 6px;
      font-size: 0.95rem;
      color: #0b0c0c;
    }
    .global-rating__donut {
      position: relative;
      width: 120px;
      height: 120px;
      margin: 0 auto;
    }
    .global-rating__value {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 1.35rem;
      letter-spacing: 0.01em;
      color: #0b0c0c;
    }
    .global-rating__meta {
      margin: 6px 0 0;
      font-size: 0.85rem;
      color: #0b0c0c;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div class="viewport">
    <div class="map-overlay zoom-target" id="mapOverlay" aria-hidden="true"></div>
    <div class="grid" aria-hidden="true"></div>
    <div class="rays-layer zoom-target" id="raysLayer" aria-hidden="true"></div>
    <div class="points-layer zoom-target" id="pointsLayer" aria-hidden="true"></div>
    <div class="zoom-bubble" id="zoomBubble"></div>
    <div class="word-cloud" id="wordCloud"></div>
    <div class="info">
      <div class="pill">
        <button id="soundCheck" type="button">üîä Probar sonido</button>
        <button id="zoomTest" type="button">üîç Probar zoom</button>
        <button id="characterTest" type="button">üé≠ Probar personaje</button>
      </div>
    </div>
    <div class="timeline">
      <div class="timeline__bubble" id="timelineBubble">
        <div class="timeline__cp"></div>
        <div class="timeline__text"></div>
      </div>
    </div>
    <div class="stats-timeline">
      <div class="stats__bubble" id="statsBubble">
        <div class="stats__title" id="statsTitle"></div>
        <div class="stats__meta" id="statsMeta"></div>
        <div class="stats__bar" id="statsBar">
          <svg class="stats__donut" viewBox="0 0 120 120" id="statsDonut"></svg>
        </div>
        <div class="stats__legend" id="statsLegend"></div>
      </div>
    </div>
    <div class="global-rating" id="globalRating" aria-live="polite">
      <p class="global-rating__title">Valoraci√≥n global</p>
      <div class="global-rating__donut">
        <svg viewBox="0 0 120 120" id="globalRatingSvg" aria-hidden="true">
          <circle cx="60" cy="60" r="44" fill="none" stroke="rgba(0,0,0,0.12)" stroke-width="12"></circle>
          <circle cx="60" cy="60" r="44" fill="none" stroke="var(--accent, #f95e8a)" stroke-width="12" stroke-dasharray="0 999" stroke-dashoffset="0" transform="rotate(-90 60 60)" id="globalRatingArc"></circle>
          <circle cx="60" cy="60" r="28" fill="#a6c5bc"></circle>
        </svg>
        <div class="global-rating__value" id="globalRatingValue">--</div>
      </div>
      <p class="global-rating__meta" id="globalRatingMeta"></p>
    </div>
    <div class="character-timeline">
      <div class="character__bubble" id="characterBubble">
        <img class="character__img" id="characterImage" alt="Personaje" />
        <div class="character__label" id="characterLabel"></div>
        <div class="character__meta" id="characterMeta"></div>
        <div class="character__donut" id="characterDonut" aria-hidden="true">
          <svg viewBox="0 0 120 120" aria-hidden="true">
            <circle cx="60" cy="60" r="44" fill="none" stroke="rgba(0,0,0,0.12)" stroke-width="12"></circle>
            <circle cx="60" cy="60" r="44" fill="none" stroke="var(--accent, #f95e8a)" stroke-width="12" stroke-dasharray="0 999" stroke-dashoffset="0" transform="rotate(-90 60 60)" id="characterDonutArc"></circle>
            <circle cx="60" cy="60" r="28" fill="#a6c5bc"></circle>
          </svg>
          <div class="character__donut-value" id="characterDonutValue">--</div>
        </div>
        <div class="character__donut-meta" id="characterDonutMeta"></div>
      </div>
    </div>
  </div>
  <audio id="soundClip" src="/data/blip.mp3" preload="auto"></audio>
  <audio id="bubbleClip" src="/data/blip2.mp3" preload="auto"></audio>
  <audio id="statsClip" src="/data/blip3.mp3" preload="auto"></audio>
  <audio id="characterClip" src="/data/blip4.mp3" preload="auto"></audio>
  <audio id="zoomClip" src="/data/blip5.mp3" preload="auto"></audio>
  <script>
    (() => {
      const overlay = document.getElementById("mapOverlay");
      if (!overlay) return;
      window.addEventListener("keydown", (ev) => {
        if (ev.key.toLowerCase() === "m") {
          overlay.classList.toggle("hidden");
        }
      });
    })();
    (() => {
      const btn = document.getElementById("soundCheck");
      const audio = document.getElementById("soundClip");
      if (!btn || !audio) return;
      btn.addEventListener("click", async () => {
        btn.disabled = true;
        btn.textContent = "Reproduciendo‚Ä¶";
        audio.currentTime = 0;
        try {
          await audio.play();
          btn.textContent = "‚úÖ Son√≥";
        } catch (err) {
          console.error("No se pudo reproducir el sonido", err);
          btn.textContent = "‚ö†Ô∏è No se pudo (Safari necesita gesto)";
        }
        setTimeout(() => {
          btn.disabled = false;
          btn.textContent = "üîä Probar sonido";
        }, 1600);
      });
    })();
    (() => {
      const layer = document.getElementById("pointsLayer");
      const raysLayer = document.getElementById("raysLayer");
      const viewport = document.querySelector(".viewport");
      const grid = document.querySelector(".grid");
      const mapOverlayEl = document.getElementById("mapOverlay");
      const wordCloud = document.getElementById("wordCloud");
      const audio = document.getElementById("soundClip");
      const bubbleAudio = document.getElementById("bubbleClip");
      const statsAudio = document.getElementById("statsClip");
      const characterAudio = document.getElementById("characterClip");
      const zoomAudio = document.getElementById("zoomClip");
      const soundBtn = document.getElementById("soundCheck");
      const zoomBtn = document.getElementById("zoomTest");
      const characterBtn = document.getElementById("characterTest");
      const zoomBubbleEl = document.getElementById("zoomBubble");
      const characterBubble = document.getElementById("characterBubble");
      const characterImage = document.getElementById("characterImage");
      const characterLabel = document.getElementById("characterLabel");
      const characterMeta = document.getElementById("characterMeta");
      const characterDonut = document.getElementById("characterDonut");
      const characterDonutArc = document.getElementById("characterDonutArc");
      const characterDonutValue = document.getElementById("characterDonutValue");
      const characterDonutMeta = document.getElementById("characterDonutMeta");
      if (!layer || !viewport) return;

      let points = [];
      let baseWidth = 1920;
      let baseHeight = 1080;
      let lastTotal = null;
      let lastMaxTs = null;
      let audioReady = false;
      let timelineItems = [];
      let timelineIndex = 0;
      let viewportRect = null;
      let statsItems = [];
      let statsIndex = 0;
      let statsTimer = null;
      let globalRating = { avg: 0, count: 0 };
      let cloudItems = [];
      const wordNodes = new Map();
      let activeWord = null;
      let activeWordTimer = null;
      let cloudLangIndex = 0;
      let cloudLangTimer = null;
      let characters = [];
      let characterTotal = 0;
      let characterIndex = 0;
      let characterTimer = null;
      let zoomTimer = null;
      let zoomTestIndex = 0;
      let zoomedMarker = null;
      let zoomBubbleTimer = null;

      const bubble = document.getElementById("timelineBubble");
      const bubbleCp = bubble?.querySelector(".timeline__cp");
      const bubbleText = bubble?.querySelector(".timeline__text");
      const statsBubble = document.getElementById("statsBubble");
      const statsTitle = document.getElementById("statsTitle");
      const statsMeta = document.getElementById("statsMeta");
      const statsBar = document.getElementById("statsBar");
      const statsDonut = document.getElementById("statsDonut");
      const statsLegend = document.getElementById("statsLegend");
      const globalRatingWrap = document.getElementById("globalRating");
      const globalRatingSvg = document.getElementById("globalRatingSvg");
      const globalRatingArc = document.getElementById("globalRatingArc");
      const globalRatingValue = document.getElementById("globalRatingValue");
      const globalRatingMeta = document.getElementById("globalRatingMeta");
      const rootStyles = getComputedStyle(document.documentElement);
      const cols = parseInt(rootStyles.getPropertyValue("--cols"), 10) || 120;
      const rows = parseInt(rootStyles.getPropertyValue("--rows"), 10) || 60;
      const cloudLangs = ["es", "eu", "en"];
      const genderColors = {
        "man": "#6da7ff",
        "woman": "#f8a1d1",
        "nonbinary": "#9b7df0",
        "otro": "#ffcf5c",
        "other": "#ffcf5c",
        "prefiero_no_decir": "#a0a0a0",
        "no_responde": "#a0a0a0",
      };
      const ageBuckets = [
        { key: "10_17", label: "10-17", color: "#6da7ff" },
        { key: "18_25", label: "18-25", color: "#f8a1d1" },
        { key: "26_35", label: "26-35", color: "#ffcf5c" },
        { key: "36_45", label: "36-45", color: "#9b7df0" },
        { key: "46_55", label: "46-55", color: "#66d399" },
        { key: "56_65", label: "56-65", color: "#ffa45c" },
        { key: "66_plus", label: "66+", color: "#ffffff" },
      ];
      const studiesLabels = {
        "obligatorios": "Obligatorios",
        "bachillerato_fp": "Bachillerato/FP",
        "universitarios": "Universitarios",
        "sin_estudios": "Sin estudios",
        "otros": "Otros",
      };
      const studiesColors = {
        "obligatorios": "#6da7ff",
        "bachillerato_fp": "#f8a1d1",
        "universitarios": "#ffcf5c",
        "sin_estudios": "#9b7df0",
        "otros": "#ffffff",
      };
      const playAudio = (el) => {
        if (!el) return;
        try {
          const clone = el.cloneNode(true);
          clone.currentTime = 0;
          clone.play().catch(() => {});
        } catch (err) {
          console.warn("No se pudo reproducir audio", err);
        }
      };
      const playBlip = () => {
        if (!audioReady) return;
        playAudio(audio);
      };
      const playBubbleBlip = () => {
        if (!audioReady) return;
        playAudio(bubbleAudio);
      };
      const playStatsBlip = () => {
        if (!audioReady) return;
        playAudio(statsAudio);
      };
      const playCharacterBlip = () => {
        if (!audioReady) return;
        playAudio(characterAudio);
      };
      const playZoomBlip = () => {
        if (!audioReady) return;
        playAudio(zoomAudio);
      };
      const asociacionesLabels = {
        "innovacion": { es: "Innovaci√≥n", eu: "Berrikuntza", en: "Innovation" },
        "educacion": { es: "Educaci√≥n", eu: "Hezkuntza", en: "Education" },
        "tradicion": { es: "Tradici√≥n", eu: "Tradizioa", en: "Tradition" },
        "integracion": { es: "Integraci√≥n", eu: "Integrazioa", en: "Integration" },
        "modernidad": { es: "Modernidad", eu: "Modernitatea", en: "Modernity" },
        "bienestar": { es: "Bienestar", eu: "Ongizatea", en: "Wellbeing" },
        "calidad_vida": { es: "Calidad de vida", eu: "Bizitza-kalitatea", en: "Quality of life" },
        "diversidad": { es: "Diversidad", eu: "Aniztasuna", en: "Diversity" },
        "talento": { es: "Talento", eu: "Talentua", en: "Talent" },
        "sostenibilidad": { es: "Sostenibilidad", eu: "Iraunkortasuna", en: "Sustainability" },
        "creatividad": { es: "Creatividad", eu: "Sormena", en: "Creativity" },
        "vanguardia": { es: "Vanguardia", eu: "Aitzindaritza", en: "Avant-garde" },
        "tecnologia": { es: "Tecnolog√≠a", eu: "Teknologia", en: "Technology" },
      };

      function buildTimelineItems(list) {
        const prevLen = timelineItems.length;
        timelineItems = [];
        list.forEach((p) => {
          (p.responses || []).forEach((r) => {
            const payload = r.payload || {};
            const labelsMap = payload.__labels || {};
            const messages = preferredFields
              .map((entry) => {
                const v = payload[entry.id];
                return typeof v === "string" && v.trim().length > 2
                  ? { label: labelsMap[entry.id] || entry.label, text: v.trim() }
                  : null;
              })
              .filter(Boolean);
            if (!messages.length) return;
            let words = [];
            const rawWords = payload.asociaciones_alava_labels || payload.asociaciones_alava;
            if (Array.isArray(rawWords)) {
              words = rawWords;
            } else if (typeof rawWords === "string") {
              words = rawWords.split(/[,;]/);
            }
            words = words
              .map((s) => (typeof s === "string" ? s.trim() : ""))
              .filter(Boolean)
              .map((s) => s.toLowerCase());
            timelineItems.push({
              cp: p.label || p.codigo_postal,
              messages,
              created_at: r.created_at || "",
              x: p.x,
              y: p.y,
              words,
            });
          });
        });
        console.log("[timeline] items", timelineItems.map((i) => ({ cp: i.cp, msgs: (i.messages || []).length })));
        if (timelineItems.length === 0 || prevLen === 0) {
          timelineIndex = 0;
        } else {
          timelineIndex = timelineIndex % timelineItems.length;
        }
      }

      function bucketAge(age) {
        if (age == null || Number.isNaN(age)) return null;
        if (age <= 17) return "10_17";
        if (age <= 25) return "18_25";
        if (age <= 35) return "26_35";
        if (age <= 45) return "36_45";
        if (age <= 55) return "46_55";
        if (age <= 65) return "56_65";
        return "66_plus";
      }

      function buildStatsItems(list) {
        const prevLen = statsItems.length;
        statsItems = [];
        let ratingSum = 0;
        let ratingCount = 0;
        list.forEach((p) => {
          const responsesTotal = Array.isArray(p.responses) ? p.responses.length : 0;
          const counts = {};
          let total = 0;
          const ratingVals = [];
          const ageCounts = {};
          (p.responses || []).forEach((r) => {
            const payload = r.payload || {};
            const lvl = (payload.nivel_estudios || "").trim();
            if (lvl) {
              counts[lvl] = (counts[lvl] || 0) + 1;
              total += 1;
            }
            const rating = Number(payload.valoracion_exposicion);
            if (!Number.isNaN(rating)) {
              ratingVals.push(rating);
              ratingSum += rating;
              ratingCount += 1;
            }
            const age = Number(payload.edad);
            const bucket = bucketAge(age);
            if (bucket) {
              ageCounts[bucket] = (ageCounts[bucket] || 0) + 1;
            }
          });
          if (total) {
            const stats = Object.entries(counts)
              .map(([key, val]) => ({
                key,
                label: studiesLabels[key] || key,
                count: val,
                color: studiesColors[key] || "#f95e8a",
              }))
              .sort((a, b) => b.count - a.count);
            statsItems.push({
              type: "studies",
              cp: p.label || p.codigo_postal,
              x: p.x,
              y: p.y,
              total,
              stats,
              response_total: responsesTotal,
            });
          }
          if (ratingVals.length) {
            const sum = ratingVals.reduce((acc, v) => acc + v, 0);
            const avg = sum / ratingVals.length;
            statsItems.push({
              type: "rating",
              cp: p.label || p.codigo_postal,
              x: p.x,
              y: p.y,
              avg,
              count: ratingVals.length,
              min: 1,
              max: 10,
              response_total: responsesTotal,
            });
          }
          const ageTotal = Object.values(ageCounts).reduce((acc, v) => acc + v, 0);
          if (ageTotal) {
            const segments = ageBuckets
              .map((b) => ({
                key: b.key,
                label: b.label,
                count: ageCounts[b.key] || 0,
                color: b.color,
              }))
              .filter((s) => s.count > 0);
            statsItems.push({
              type: "age",
              cp: p.label || p.codigo_postal,
              x: p.x,
              y: p.y,
              total: ageTotal,
              stats: segments.sort((a, b) => b.count - a.count),
              response_total: responsesTotal,
            });
          }
        });
        if (statsItems.length === 0 || prevLen === 0) {
          statsIndex = 0;
        } else {
          statsIndex = statsIndex % statsItems.length;
        }
        globalRating = {
          avg: ratingCount ? ratingSum / ratingCount : 0,
          count: ratingCount,
        };
      }

      function buildCloudItems(list) {
        const freq = {};
        list.forEach((p) => {
          (p.responses || []).forEach((r) => {
            const rawVals = r.payload?.asociaciones_alava_values || r.payload?.asociaciones_alava;
            const rawLabels = r.payload?.asociaciones_alava_labels;
            let values = [];
            if (Array.isArray(rawVals)) values = rawVals;
            else if (typeof rawVals === "string") values = rawVals.split(/[,;]/);
            if (!values.length && rawLabels) {
              if (Array.isArray(rawLabels)) values = rawLabels;
              else if (typeof rawLabels === "string") values = rawLabels.split(/[,;]/);
            }
            values
              .map((s) => (typeof s === "string" ? s.trim() : ""))
              .filter(Boolean)
              .forEach((val) => {
                const key = val.toLowerCase();
                freq[key] = (freq[key] || { count: 0, value: key });
                freq[key].count += 1;
              });
          });
        });
        cloudItems = Object.values(freq).sort((a, b) => b.count - a.count).slice(0, 12);
      }

      function renderCloud() {
        if (!wordCloud) return;
        wordCloud.innerHTML = "";
        wordNodes.clear();
        if (!cloudItems.length) return;
        cloudLangIndex = 0;
        const max = cloudItems[0].count;
        const min = cloudItems[cloudItems.length - 1].count;
        const spread = Math.max(1, max - min);
        cloudItems.forEach((entry) => {
          const word = entry.value;
          const count = entry.count;
          const labels = asociacionesLabels[word] || { es: word, eu: word, en: word };
          const span = document.createElement("span");
          span.className = "word-cloud__item";
          const size = 14 + Math.round(((count - min) / spread) * 20);
          span.style.fontSize = `${size}px`;
          span.textContent = labels[cloudLangs[cloudLangIndex]] || word;
          span.title = `${count} menciones`;
          const dx = (Math.random() * 6 + 3) * (Math.random() > 0.5 ? 1 : -1);
          const dy = (Math.random() * 5 + 2) * (Math.random() > 0.5 ? 1 : -1);
          const delay = (Math.random() * 5).toFixed(2);
          const duration = (10 + Math.random() * 6).toFixed(2);
          span.style.setProperty("--wc-dx", `${dx}px`);
          span.style.setProperty("--wc-dy", `${dy}px`);
          span.style.animationDelay = `${delay}s`;
          span.style.setProperty("--wc-duration", `${duration}s`);
          const norm = word.toString().toLowerCase();
          if (activeWord && activeWord === norm) {
            span.classList.add("is-active");
          }
          wordNodes.set(norm, { el: span, labels, tick: Math.random() * 1.2 + 0.6 });
          wordCloud.appendChild(span);
        });
        if (cloudLangTimer) clearInterval(cloudLangTimer);
        const rotateWord = (key, data) => {
          const { el, labels } = data;
          const langIdx = Math.floor(Math.random() * cloudLangs.length);
          const txt = labels[cloudLangs[langIdx]] || labels.es || labels.eu || labels.en;
          el.textContent = txt;
          const delay = 3000 + Math.random() * 3000;
          setTimeout(() => rotateWord(key, data), delay);
        };
        wordNodes.forEach((data, key) => {
          const delay = 3000 + Math.random() * 3000;
          setTimeout(() => rotateWord(key, data), delay);
        });
      }

      function setActiveWord(word) {
        if (activeWordTimer) clearTimeout(activeWordTimer);
        if (activeWord && wordNodes.has(activeWord)) {
          const prev = wordNodes.get(activeWord);
          prev?.el?.classList.remove("is-active");
        }
        activeWord = word;
        const el = word ? wordNodes.get(word) : null;
        if (el?.el) {
          el.el.classList.add("is-active");
          activeWordTimer = setTimeout(() => {
            el.el.classList.remove("is-active");
            activeWord = null;
          }, 6000);
        }
      }

      function updateCharacterDonut(item) {
        if (!characterDonut || !characterDonutArc || !characterDonutValue || !characterDonutMeta) return;
        const count = item?.count != null ? item.count : 0;
        const total = characterTotal || (count > 0 ? count : 0);
        characterDonut.style.display = "block";
        const pctBase = total ? (count / total) * 100 : (item?.percentage || 0);
        const pct = Math.max(0, Math.min(100, pctBase));
        const radius = 44;
        const circumference = 2 * Math.PI * radius;
        const dash = (pct / 100) * circumference;
        const gap = Math.max(circumference - dash, 0);
        characterDonutArc.setAttribute("stroke-dasharray", `${dash} ${gap}`);
        characterDonutArc.setAttribute("stroke-dashoffset", "0");
        characterDonutValue.textContent = `${count}`;
        const pctLabel = `${Math.round(pct)}%`;
        const totalLabel = total || characterTotal || 0;
        characterDonutMeta.textContent = totalLabel ? `${count} / ${totalLabel} ¬∑ ${pctLabel}` : `${count} ¬∑ ${pctLabel}`;
      }

      function showNextCharacter() {
        if (!characterBubble || !characters.length || !viewportRect) return;
        if (characterBubble.classList.contains("visible")) {
          scheduleCharacter();
          return;
        }
        const item = characters[characterIndex % characters.length];
        characterIndex = (characterIndex + 1) % characters.length;
        if (characterImage && item.image) {
          characterImage.src = item.image;
        }
        if (characterLabel) {
          characterLabel.textContent = item.label || "Personaje";
        }
        if (characterMeta) {
          const pct = item.percentage != null ? `${item.percentage}%` : "";
          const count = item.count != null ? item.count : null;
          const totalStr = characterTotal ? ` / ${characterTotal}` : "";
          const votesLabel = count != null ? `Votos: ${count}${totalStr}` : "";
          characterMeta.textContent = pct ? `${votesLabel} ¬∑ ${pct}` : votesLabel;
        }
        updateCharacterDonut(item);
        characterBubble.classList.add("visible");
        playCharacterBlip();
        setTimeout(() => characterBubble.classList.remove("visible"), 5200);
        scheduleCharacter();
      }

      function scheduleCharacter() {
        if (characterTimer) clearTimeout(characterTimer);
        if (!characters.length) return;
        const delay = 7000 + Math.random() * 7000;
        characterTimer = setTimeout(showNextCharacter, delay);
      }

      function animateZoomTo(col, row, point) {
        if (!viewportRect) return;
        const x = ((col + 1) / cols) * viewportRect.width;
        const y = ((row + 0.5) / rows) * viewportRect.height;
        const centerX = viewportRect.width / 2;
        const centerY = viewportRect.height / 2;
        const tx = centerX - x;
        const ty = centerY - y;
        // Mant√©n la cuadr√≠cula est√°tica, solo mueve/escala capas de contenido
        const targets = [mapOverlayEl, raysLayer, layer].filter(Boolean);
        targets.forEach((el) => {
          el.style.transform = `translate(${tx}px, ${ty}px) scale(2.4)`;
        });
        if (zoomBubbleEl && point) {
          zoomBubbleEl.style.left = `${x}px`;
          zoomBubbleEl.style.top = `${y}px`;
          const cpTxt = point.codigo_postal || point.label || "CP";
          const locTxt = point.label ? point.label : "";
          const countTxt = point.count ? `Entradas: ${point.count}` : "";
          zoomBubbleEl.innerHTML = `
            <strong>Nueva entrada en ${locTxt || "Localidad"}!</strong>
            <div>C√≥digo postal: ${cpTxt}</div>
            ${countTxt ? `<div>${countTxt}</div>` : ""}
          `;
          zoomBubbleEl.classList.add("visible");
          if (zoomBubbleTimer) clearTimeout(zoomBubbleTimer);
          zoomBubbleTimer = setTimeout(() => {
            zoomBubbleEl.classList.remove("visible");
          }, 2600);
        }
        playZoomBlip();
        zoomedMarker = null;
        if (zoomTimer) clearTimeout(zoomTimer);
        zoomTimer = setTimeout(() => {
          targets.forEach((el) => {
            el.style.transform = `translate(${tx}px, ${ty}px) scale(2.4)`;
          });
          setTimeout(() => {
            targets.forEach((el) => {
              el.style.transform = "translate(0,0) scale(1)";
            });
            zoomedMarker = null;
          }, 2000);
        }, 300);
      }

      function drawRays(lines) {
        if (!raysLayer || !viewportRect) return;
        raysLayer.innerHTML = "";
        if (!Array.isArray(lines) || !lines.length) return;
        const thickness = 3;
        const width = viewportRect.width;
        const height = viewportRect.height;
        lines.forEach((line) => {
          const dir = typeof line.dir === "number" ? line.dir : 0;
          const color = line.color || "#f95e8a";
          const startX = Math.max(0, Math.min(width, line.x || 0));
          const startY = Math.max(0, Math.min(height, line.y || 0));
          const el = document.createElement("div");
          el.className = "ray";
          el.style.background = color;
          if (dir === 0) {
            el.style.left = `${startX - thickness / 2}px`;
            el.style.top = "0px";
            el.style.width = `${thickness}px`;
            el.style.height = `${startY}px`;
          } else if (dir === 1) {
            el.style.left = `${startX}px`;
            el.style.top = `${startY - thickness / 2}px`;
            el.style.width = `${Math.max(0, width - startX)}px`;
            el.style.height = `${thickness}px`;
          } else if (dir === 2) {
            el.style.left = `${startX - thickness / 2}px`;
            el.style.top = `${startY}px`;
            el.style.width = `${thickness}px`;
            el.style.height = `${Math.max(0, height - startY)}px`;
          } else {
            el.style.left = "0px";
            el.style.top = `${startY - thickness / 2}px`;
            el.style.width = `${startX}px`;
            el.style.height = `${thickness}px`;
          }
          raysLayer.appendChild(el);
        });
      }

      const preferredFields = [
        { id: "comentarios", label: "Comentarios" },
        { id: "comentario", label: "Comentarios" },
        { id: "comentarios_generales", label: "Comentarios generales" },
        { id: "comentario_exposicion", label: "Comentario sobre la exposici√≥n" },
        { id: "contenido_interesante_comentario", label: "¬øPor qu√© fue interesante?" },
        { id: "personaje_atencion_comentario", label: "Sobre el personaje elegido" },
        { id: "aprendizaje_alava", label: "¬øQu√© aprendiste sobre √Ålava?" },
        { id: "algo_en_falta", label: "¬øQu√© falt√≥?" },
        { id: "asociaciones_alava", label: "Asociaciones con √Ålava" },
        { id: "orgullo_alava", label: "Orgullo de √Ålava" },
        { id: "sentirse_alaves", label: "¬øTe sientes alav√©s?" },
        { id: "visitas_expos_comentario", label: "Sobre la exposici√≥n" },
        { id: "temas_futuros", label: "Temas futuros" },
        { id: "actividades_centro", label: "Actividades centro" },
        { id: "conoces_vital_comentario", label: "Conoces Vital (comentario)" },
      ];

      function hasCommentsForPayload(payload) {
        if (!payload) return false;
        return preferredFields.some((entry) => {
          const v = payload[entry.id];
          return typeof v === "string" && v.trim().length > 0;
        });
      }

      function pickMessage(payload) {
        if (!payload) return null;
        const labelsMap = payload.__labels || {};
        for (const entry of preferredFields) {
          const v = payload[entry.id];
          if (typeof v === "string" && v.trim().length > 2) {
            const lbl = labelsMap[entry.id] || entry.label;
            return { label: lbl, text: v.trim() };
          }
        }
        return null;
      }

      function showNextTimeline() {
        if (!bubble || timelineItems.length === 0 || !viewportRect) return;
        if (bubble.classList.contains("visible")) {
          return;
        }
        const item = timelineItems[timelineIndex % timelineItems.length];
        timelineIndex = (timelineIndex + 1) % timelineItems.length;
        const msgs = item.messages || [];
        const msg = msgs.length ? msgs[Math.floor(Math.random() * msgs.length)] : null;
        if (!msg) return;
        const cpLabel = item.cp || "CP";
        const questionLabel = msg.label ? ` ¬∑ ${msg.label}` : "";
        const msgText = msg.text || "";
        bubbleCp.textContent = `${cpLabel}${questionLabel}`;
        bubbleText.textContent = msgText;
        console.log("[timeline] mostrando", item.cp, "msg:", msgText.slice(0,80));
        if (item.words && item.words.length) {
          const pick = item.words[Math.floor(Math.random() * item.words.length)];
          setActiveWord(pick);
        } else {
          setActiveWord(null);
        }
        let left = viewportRect.width / 2;
        let top = viewportRect.height / 2;
        if (typeof item.x === "number" && typeof item.y === "number" && baseWidth && baseHeight) {
          left = (item.x / baseWidth) * viewportRect.width;
          top = (item.y / baseHeight) * viewportRect.height;
        }
        const padding = 20;
        const offsetX = 80; // desplaza hacia la derecha
        const offsetY = -80; // desplaza hacia arriba
        left = Math.max(padding, Math.min(viewportRect.width - padding, left + offsetX));
        top = Math.max(padding, Math.min(viewportRect.height - padding, top + offsetY));
        bubble.style.left = `${left}px`;
        bubble.style.top = `${top}px`;
        bubble.classList.add("visible");
        setTimeout(() => bubble.classList.remove("visible"), 6000);
        playBubbleBlip();
      }

      function showNextStats() {
        if (!statsBubble || statsItems.length === 0 || !viewportRect) {
          scheduleStats();
          return;
        }
        // Evita coincidir con el globo de comentarios
        if (bubble && bubble.classList.contains("visible")) {
          scheduleStats();
          return;
        }
        const item = statsItems[statsIndex % statsItems.length];
        statsIndex = (statsIndex + 1) % statsItems.length;
        const segments = item.stats ? item.stats.slice(0, 6) : [];
        const total = item.total || 1;
        if (statsLegend) statsLegend.innerHTML = "";
        if (statsMeta) statsMeta.textContent = "";
        if (statsBar) statsBar.innerHTML = "";

        if (item.type === "rating") {
          statsTitle.textContent = `${item.cp || "CP"} ¬∑ Valoraci√≥n exposici√≥n`;
          const track = document.createElement("div");
          track.className = "stats__rating-track";
          const fill = document.createElement("div");
          fill.className = "stats__rating-fill";
          const pct = Math.max(0, Math.min(100, ((item.avg - item.min) / (item.max - item.min)) * 100));
          fill.style.width = `${pct}%`;
          track.appendChild(fill);
          const labels = document.createElement("div");
          labels.className = "stats__rating-labels";
          const left = document.createElement("span");
          left.textContent = `${item.min}`;
          const mid = document.createElement("span");
          mid.innerHTML = `<span class="stats__rating-value">${item.avg.toFixed(1)}</span> (${item.count} respuestas)`;
          const right = document.createElement("span");
          right.textContent = `${item.max}`;
          labels.appendChild(left);
          labels.appendChild(mid);
          labels.appendChild(right);
          const wrap = document.createElement("div");
          wrap.className = "stats__rating";
          wrap.appendChild(track);
          wrap.appendChild(labels);
          statsBar.appendChild(wrap);
          if (statsMeta) {
            const totalResp = item.response_total || item.count || 0;
            const pct = totalResp ? Math.round((item.count / totalResp) * 100) : 0;
            statsMeta.textContent = `Votos: ${item.count || 0} / ${totalResp} ¬∑ ${pct}%`;
          }
        } else {
          const titleLabel = item.type === "age" ? "Edades" : "Nivel de estudios";
          statsTitle.textContent = `${item.cp || "CP"} ¬∑ ${titleLabel}`;
          const sourceSegments = item.type === "age" ? item.stats : segments;
          if (statsMeta) {
            const votes = total || 0;
            const totalResp = item.response_total || votes;
            const pct = totalResp ? Math.round((votes / totalResp) * 100) : 0;
            statsMeta.textContent = `Votos: ${votes} / ${totalResp} ¬∑ ${pct}%`;
          }
          if (statsBar) {
            const donut = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            donut.setAttribute("viewBox", "0 0 120 120");
            donut.classList.add("stats__donut");
            let offset = 0;
            sourceSegments.forEach((seg) => {
              const pct = (seg.count / total) * 100;
              const circumference = 2 * Math.PI * 45;
              const dash = (pct / 100) * circumference;
              const gap = circumference - dash;
              const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
              circle.setAttribute("cx", "60");
              circle.setAttribute("cy", "60");
              circle.setAttribute("r", "45");
              circle.setAttribute("fill", "none");
              circle.setAttribute("stroke", seg.color);
              circle.setAttribute("stroke-width", "12");
              circle.setAttribute("stroke-dasharray", `${dash} ${gap}`);
              circle.setAttribute("stroke-dashoffset", `${-offset}`);
              circle.setAttribute("transform", "rotate(-90 60 60)");
              donut.appendChild(circle);
              offset += dash;
            });
            const inner = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            inner.setAttribute("cx", "60");
            inner.setAttribute("cy", "60");
            inner.setAttribute("r", "25");
            inner.setAttribute("fill", "#a6c5bc");
            donut.appendChild(inner);
            statsBar.appendChild(donut);
          }
          if (statsLegend) {
            sourceSegments.forEach((seg) => {
              const pct = Math.round((seg.count / total) * 100);
              const itemRow = document.createElement("div");
              itemRow.className = "stats__legend-item";
              const sw = document.createElement("span");
              sw.className = "stats__swatch";
              sw.style.background = seg.color;
              const txt = document.createElement("span");
              txt.textContent = `${seg.label}: ${pct}%`;
              itemRow.appendChild(sw);
              itemRow.appendChild(txt);
              statsLegend.appendChild(itemRow);
            });
          }
        }
        let left = viewportRect.width / 2;
        let top = viewportRect.height / 2;
        if (typeof item.x === "number" && typeof item.y === "number" && baseWidth && baseHeight) {
          left = (item.x / baseWidth) * viewportRect.width;
          top = (item.y / baseHeight) * viewportRect.height;
        }
        const padding = 20;
        const offsetX = -140; // izquierda del punto
        const offsetY = -40;  // un poco arriba
        left = Math.max(padding, Math.min(viewportRect.width - padding, left + offsetX));
        top = Math.max(padding, Math.min(viewportRect.height - padding, top + offsetY));
        statsBubble.style.left = `${left}px`;
        statsBubble.style.top = `${top}px`;
        statsBubble.classList.add("visible");
        setTimeout(() => statsBubble.classList.remove("visible"), 6000);
        playStatsBlip();
        scheduleStats();
      }

      function renderGlobalRating() {
        if (!globalRatingWrap || !globalRatingArc || !globalRatingValue || !globalRatingMeta) return;
        if (!globalRating.count) {
          globalRatingWrap.style.display = "none";
          return;
        }
        globalRatingWrap.style.display = "block";
        const pct = Math.max(0, Math.min(100, (globalRating.avg / 10) * 100));
        const radius = 44;
        const circumference = 2 * Math.PI * radius;
        const dash = (pct / 100) * circumference;
        const gap = Math.max(circumference - dash, 0);
        globalRatingArc.setAttribute("stroke-dasharray", `${dash} ${gap}`);
        globalRatingArc.setAttribute("stroke-dashoffset", "0");
        globalRatingValue.textContent = globalRating.avg.toFixed(1);
        globalRatingMeta.textContent = `${globalRating.count} votos`;
      }

      function render() {
        const rect = viewport.getBoundingClientRect();
        viewportRect = rect;
        const cellW = rect.width / cols;
        const cellH = rect.height / rows;
        if (grid) {
          grid.style.setProperty("--cell-x", `${cellW}px`);
          grid.style.setProperty("--cell-y", `${cellH}px`);
        }
        layer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        layer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
        layer.style.width = `${rect.width}px`;
        layer.style.height = `${rect.height}px`;
        const layerRect = layer.getBoundingClientRect();
        layer.innerHTML = "";
        const rayLines = [];
        points.forEach((p) => {
          if (p.x == null || p.y == null) return;
          let col = Math.max(0, Math.min(cols - 1, Math.floor((p.x / baseWidth) * cols)));
          const row = Math.max(0, Math.min(rows - 1, Math.floor((p.y / baseHeight) * rows)));
          if (col === cols - 1) col = cols - 2; // deja espacio para el cuadrito de g√©nero

          // Mayor√≠a de g√©nero
          let topGender = null;
          let topCount = -1;
          if (p.gender_counts) {
            Object.entries(p.gender_counts).forEach(([g, c]) => {
              if (c > topCount) {
                topCount = c;
                topGender = g;
              }
            });
          }
          const genderColor = topGender ? (genderColors[topGender] || "#999") : "#999";
          const genderBg = p.external ? "rgba(249, 94, 138, 0.5)" : genderColor;

          const wrap = document.createElement("div");
          wrap.className = "marker-pair";
          wrap.style.gridColumn = `${col + 1} / span 2`;
          wrap.style.gridRow = `${row + 1}`;

          const countEl = document.createElement("div");
          countEl.className = "marker";
          const noComments = !(p.responses || []).some((r) => hasCommentsForPayload(r.payload));
          if (noComments) countEl.classList.add("no-comments");
          if (p.external) countEl.classList.add("external");
          countEl.textContent = p.count;
          countEl.title = `${p.label || p.codigo_postal} ¬∑ ${p.count}`;

          const genderEl = document.createElement("div");
          genderEl.className = "marker gender";
          if (p.external) genderEl.classList.add("external");
          genderEl.style.background = genderBg;
          genderEl.title = topGender ? `G√©nero mayoritario: ${topGender}` : "Sin g√©nero";

          // Nivel de estudios predominante
          const studyCounts = {};
          let studyTotal = 0;
          (p.responses || []).forEach((r) => {
            const lvl = (r.payload?.nivel_estudios || "").trim();
            if (!lvl) return;
            studyCounts[lvl] = (studyCounts[lvl] || 0) + 1;
            studyTotal += 1;
          });
          let topStudy = null;
          let topStudyCount = -1;
          Object.entries(studyCounts).forEach(([k, v]) => {
            if (v > topStudyCount) {
              topStudy = k;
              topStudyCount = v;
            }
          });
          const studyColor = topStudy ? (studiesColors[topStudy] || "#ccc") : "#ccc";
          const studyEl = document.createElement("div");
          studyEl.className = "marker study";
          if (p.external) studyEl.classList.add("external");
          studyEl.style.background = p.external ? "rgba(249, 94, 138, 0.5)" : studyColor;
          const studyPct = studyTotal ? Math.round((topStudyCount / studyTotal) * 100) : 0;
          studyEl.title = topStudy ? `Estudios: ${studiesLabels[topStudy] || topStudy} (${studyPct}%)` : "Sin datos de estudios";

          wrap.appendChild(countEl);
          wrap.appendChild(genderEl);
          studyEl.style.gridColumn = "1";
          studyEl.style.gridRow = "2";
          wrap.appendChild(studyEl);
          layer.appendChild(wrap);

          if (p.__recent) {
            let startX = ((col + 1.5) / cols) * rect.width;
            let startY = ((row + 0.25) / rows) * rect.height;
            const dir = p.__dir || 0;
            if (layerRect && typeof layerRect.left === "number") {
              const gRect = genderEl.getBoundingClientRect();
              startX = gRect.left - layerRect.left + gRect.width / 2;
              startY = gRect.top - layerRect.top + gRect.height / 2;
              if (dir === 1 || dir === 3) {
                startY += gRect.height / 7; // ajuste fino hacia abajo solo para horizontales
              }
            }
            rayLines.push({
              x: startX,
              y: startY,
              dir,
              color: genderColor,
            });
          }
          if (zoomedMarker && zoomedMarker.cp === p.codigo_postal) {
            countEl.classList.add("is-zoomed");
          }
        });
        drawRays(rayLines);
      }

      async function loadPoints() {
        try {
          const res = await fetch("/api/visual/points?status=all");
          if (!res.ok) throw new Error("Failed to load points");
          const data = await res.json();
          baseWidth = data?.base_size?.width || baseWidth;
          baseHeight = data?.base_size?.height || baseHeight;
          points = (data?.points || []).map((p) => ({ ...p, __recent: false, __dir: 0 }));
          const incomingChars = Array.isArray(data?.characters) ? data.characters : [];
          const changedChars = JSON.stringify(incomingChars) !== JSON.stringify(characters);
          if (changedChars) {
            characters = incomingChars;
            characterTotal = characters.reduce((acc, c) => acc + (c.count || 0), 0);
            characterIndex = 0;
          }
          buildTimelineItems(points);
          buildStatsItems(points);
          buildCloudItems(points);
          // Marca las 3 m√°s recientes seg√∫n latest_at
          const withTime = points
            .map((p) => ({
              p,
              t: p.latest_at ? new Date(p.latest_at).getTime() : 0,
            }))
            .sort((a, b) => a.t - b.t);
          const recent = withTime.slice(-3);
          recent.forEach((entry, idx) => {
            entry.p.__recent = true;
            entry.p.__dir = idx % 4;
          });
          const total = points.reduce((acc, p) => acc + (p.count || 0), 0);
          console.log("[grid] puntos cargados:", points.length, "total respuestas:", total);
          const maxTs = Math.max(
            0,
            ...points.map((p) => (p.latest_at ? new Date(p.latest_at).getTime() : 0))
          );
          const isNewer = lastMaxTs !== null && maxTs > lastMaxTs;
          const isMore = lastTotal !== null && total > lastTotal;
          if (audioReady && (isMore || isNewer)) {
            playBlip();
          }
          if ((isNewer || isMore) && withTime.length) {
            const newest = withTime[withTime.length - 1]?.p;
            if (newest && newest.x != null && newest.y != null) {
              const colZoom = Math.max(0, Math.min(cols - 1, Math.floor((newest.x / baseWidth) * cols)));
              const rowZoom = Math.max(0, Math.min(rows - 1, Math.floor((newest.y / baseHeight) * rows)));
              zoomedMarker = { cp: newest.codigo_postal || newest.label };
              animateZoomTo(colZoom, rowZoom, newest);
            }
          }
          lastTotal = total;
          lastMaxTs = maxTs;
          render();
          renderCloud();
          renderGlobalRating();
          if (characters.length) {
            setTimeout(() => {
              showNextCharacter();
            }, 150);
          }
          scheduleCharacter();
          scheduleStats();
          showNextTimeline();
        } catch (err) {
          console.error(err);
        }
      }

      window.addEventListener("resize", render);
      window.addEventListener("keydown", (ev) => {
        if (ev.key.toLowerCase() === "r") {
          loadPoints();
        }
        audioReady = true;
      });
      window.addEventListener("click", () => { audioReady = true; }, { once: true });

      if (soundBtn) {
        soundBtn.addEventListener("click", async () => {
          audioReady = true;
          soundBtn.disabled = true;
          soundBtn.textContent = "Reproduciendo‚Ä¶";
          try {
            playBlip();
            soundBtn.textContent = "‚úÖ Son√≥";
          } catch (err) {
            soundBtn.textContent = "‚ö†Ô∏è No se pudo";
          }
          setTimeout(() => {
            soundBtn.disabled = false;
            soundBtn.textContent = "üîä Probar sonido";
          }, 1600);
        });
      }
      if (zoomBtn) {
        zoomBtn.addEventListener("click", () => {
          if (!points.length) return;
          const withTime = points
            .map((p) => ({
              p,
              t: p.latest_at ? new Date(p.latest_at).getTime() : 0,
            }))
            .sort((a, b) => a.t - b.t);
          if (!withTime.length) return;
          const pick = withTime[zoomTestIndex % withTime.length]?.p;
          zoomTestIndex = (zoomTestIndex + 1) % withTime.length;
          if (pick && pick.x != null && pick.y != null) {
            const colZoom = Math.max(0, Math.min(cols - 1, Math.floor((pick.x / baseWidth) * cols)));
            const rowZoom = Math.max(0, Math.min(rows - 1, Math.floor((pick.y / baseHeight) * rows)));
            zoomedMarker = { cp: pick.codigo_postal || pick.label };
            animateZoomTo(colZoom, rowZoom, pick);
          }
        });
      }
      if (characterBtn) {
        characterBtn.addEventListener("click", () => {
          audioReady = true;
          if (!characters.length) {
            console.warn("[character] No hay personajes para mostrar");
            return;
          }
          showNextCharacter();
        });
      }

      function scheduleStats() {
        if (statsTimer) clearTimeout(statsTimer);
        const delay = 4000 + Math.random() * 11000; // 4s a 15s
        statsTimer = setTimeout(showNextStats, delay);
      }
      scheduleStats();
      loadPoints();
      setInterval(loadPoints, 10000);
      setInterval(showNextTimeline, 10000);
    })();
  </script>
</body>
</html>
